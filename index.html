<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Land use statistics map</title>

    <!-- Custom CSS styles -->
    <style type="text/css">
      body {
        margin: 25px;
      }

      #map {
        width: 900px;
        height: 600px;
        border: 1px solid silver;
        background: #E6E6E6;
      }

      /* Thanks to http://colorbrewer2.org/ */
      .YlGnBu .q0-9{fill:rgb(255,255,217)}
      .YlGnBu .q1-9{fill:rgb(237,248,177)}
      .YlGnBu .q2-9{fill:rgb(199,233,180)}
      .YlGnBu .q3-9{fill:rgb(127,205,187)}
      .YlGnBu .q4-9{fill:rgb(65,182,196)}
      .YlGnBu .q5-9{fill:rgb(29,145,192)}
      .YlGnBu .q6-9{fill:rgb(34,94,168)}
      .YlGnBu .q7-9{fill:rgb(37,52,148)}
      .YlGnBu .q8-9{fill:rgb(8,29,88)}
    </style>
  </head>
  <body>
    <h3>Land use statistics map</h3>
    <div id="map"><!-- Map container --></div>

    <!-- JS libraries -->
    <script src="//d3js.org/d3.v3.min.js"></script>

    <!-- Custom JS code -->
    <script type="text/javascript">

      // We specify the dimensions for the map container. We use the same
      // width and height as specified in the CSS above.
      var width = 900,
          height = 600;

      // We create a SVG element in the map container and give it some
      // dimensions.
      var svg = d3.select('#map').append('svg')
        .attr('width', width)
        .attr('height', height);

      // We define a geographical projection
      //     https://github.com/mbostock/d3/wiki/Geo-Projections
      // and set some dummy initial scale. The correct scale, center and
      // translate parameters will be set once the features are loaded.
      var projection = d3.geo.mercator()
        .scale(1);

      // We prepare a path object and apply the projection to it.
      var path = d3.geo.path()
        .projection(projection);

      // We prepare an object to later have easier access to the data.
      var dataById = d3.map();

      // We create a quantize scale to categorize the values in 9 groups.
      // The domain is static and has a maximum of 100 (based on the
      // assumption that no value can be larger than 100%).
      // The scale returns text values which can be used for the color CSS
      // classes (q0-9, q1-9 ... q8-9)
      var quantize = d3.scale.quantize()
          .domain([0, 100])
          .range(d3.range(9).map(function(i) { return 'q' + i + '-9'; }));

      // Load the features from the GeoJSON.
      d3.json('data/ch_municipalities.geojson', function(error, features) {

        // Get the scale and center parameters from the features.
        var scaleCenter = calculateScaleCenter(features);

        // Apply scale, center and translate parameters.
        projection.scale(scaleCenter.scale)
          .center(scaleCenter.center)
          .translate([width/2, height/2]);

        // Read the data for the cartogram
        d3.csv('data/areastatistics.csv', function(data) {

          // This maps the data of the CSV so it can be easily accessed by
          // the ID of the municipality, for example: dataById[2196]
          dataById = d3.nest()
            .key(function(d) { return d.id; })
            .rollup(function(d) { return d[0]; })
            .map(data);

          // We add a <g> element to the SVG element and give it a class to
          // style it later. We also add a class name for Colorbrewer.
          svg.append('g')
              .attr('class', 'features YlGnBu')
            // D3 wants us to select the (non-existing) path objects first ...
            .selectAll('path')
              // ... and then enter the data. For each feature, a <path>
              // element is added.
              .data(features.features)
            .enter().append('path')
              .attr('class', function(d) {
                // Use the quantized value for the class
                return quantize(dataById[d.properties.GMDNR].urban);
              })
              // As "d" attribute, we set the path of the feature.
              .attr('d', path);

        });

      });

      /**
       * Calculate the scale factor ant the center coordinates of a GeoJSON
       * FeatureCollection. For the calculation, the height and width of the
       * map container is needed.
       *
       * Thanks to: http://stackoverflow.com/a/17067379/841644
       *
       * @param {object} features - A GeoJSON FeatureCollection object
       *   containing a list of features.
       *
       * @return {object} An object containing the following attributes:
       *   - scale: The calculated scale factor.
       *   - center: A list of two coordinates marking the center.
       */
      function calculateScaleCenter(features) {
        // Get the bounding box of the paths (in pixels!) and calculate a
        // scale factor based on the size of the bounding box and the map
        // size.
        var bbox_path = path.bounds(features),
            scale = 0.95 / Math.max(
                     (bbox_path[1][0] - bbox_path[0][0]) / width,
                     (bbox_path[1][1] - bbox_path[0][1]) / height
                 );

        // Get the bounding box of the features (in map units!) and use it
        // to calculate the center of the features.
        var bbox_feature = d3.geo.bounds(features),
            center = [
              (bbox_feature[1][0]+bbox_feature[0][0])/2,
              (bbox_feature[1][1]+bbox_feature[0][1])/2]
            ;

        return {
          'scale': scale,
          'center': center
        };
      }

    </script>
  </body>
</html>
